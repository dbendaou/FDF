#include "fdf.h"


void	myseg_trace1(t_map *map1, t_map *map2, t_env *env)
{
	t_tmp *tmp;
	int DX;
	int DY;
	int TP;
	int X;
	int Y;
	int DELTAE;
	int DELTANE;
	int DP;

	tmp = (t_tmp *)malloc(sizeof(t_tmp));

	if (Y0 > Y1)
	{
		TP = X0;
		X0 = X1;
		X1 = TP;
		TP = Y0;
		Y0 = Y1;
		Y1 = TP;
	}
	DX = (X1 >= X0) ? X1 - X0 : X0 - X1;
	DY = Y1 - Y0;
	if (X1 >= X0)
	{
		if (DX >= DY)
		{
			//cas1
			DP = 2 * DY - DX;
			DELTAE = 2 * DY;
			DELTANE = 2 * (DY - DX);
			X = X0;
			Y = Y0;
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			while (X < X1)
			{
				if (DP <= 0)
				{
					DP = DP + DELTAE;
					X++;
				}
				else
				{
					DP = DP + DELTANE;
					X++;
					Y++;
				}
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			}
		}
		else
		{
			//cas2
			DP = 2 * DX - DY;
			DELTAE = 2 * DX;
			DELTANE = 2 * (DX - DY);
			X = X0;
			Y = Y0;
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			while (Y < Y1)
			{
				if (DP <= 0)
				{
					DP = DP + DELTAE;
					Y++;
				}
				else
				{
					DP = DP + DELTANE;
					X++;
					Y++;
				}
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			}
		}
	}
	else
	{
		if (DX >= DY)
		{
			//cas3
			DP = 2 * DY - DX;
			DELTAE = 2 * DY;
			DELTANE = 2 * (DY - DX);
			X = X0;
			Y = Y0;
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			while (X > X1)
			{
				if (DP <= 0)
				{
					DP = DP + DELTAE;
					X--;
				}
				else
				{
					DP = DP + DELTANE;
					X--;
					Y++;
				}
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			}
		}
		else
		{
			//cas4
			DP = 2 * DX - DY;
			DELTAE = 2 * DX;
			DELTANE = 2 * (DX - DY);
			X = X0;
			Y = Y0;
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			while (X > X1)
			{
				if (DP <= 0)
				{
					DP = DP + DELTAE;
					Y++;
				}
				else
				{
					DP = DP + DELTANE;
					X--;
					Y++;
				}
			mlx_pixel_put(env->mlx, env->win, X, Y, 0X00FFFFFF);
			}
		}
	}
}

void	int_swap(int *a, int *b)
{
	int	c;

	c = *a;
	*a = *b;
	*b = c;
}

void		 my_firstseg(int x0, int y0, int x1, t_env *env, int* dd)
 {
 	int x;
 	int y;
 	int dp;
 	int deltaE;
 	int deltaNE;

	dp = 2 * dd[1] - dd[0];
	deltaE = 2 * dd[1];
	deltaNE = 2 * (dd[1] - dd[0]);
	x = x0;
	y = y0;
	mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
	while (x < x1)
	{
		if (dp <= 0 && (x++ || x == 0))
			dp = dp + deltaE;
			// x++;
		else
		{
			dp = dp + deltaNE;
			x++;
			y++;
		}
		mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
	}
 }

void	my_seg_trace(int x0, int y0, int x1, int y1, t_env *env)
{
	int		x;
	int		y;
	int		dd[2];
	int		deltaE;
	int		deltaNE;
	int		dp;

	if (y0 > y1)
	{
		int_swap(&x1, &x0);
		int_swap(&y1, &y0);
	}
	dd[0] = (x1 >= x0) ? x1 - x0 : x0 - x1;
	dd[1] = y1 - y0;
	if (x1 >= x0)
	{
		if (dd[0] >= dd[1])
			my_firstseg(x0, y0, x1, env, dd);
		else
		{
			//cas2
			dp = 2 * dd[0] - dd[1];
			deltaE = 2 * dd[0];
			deltaNE = 2 * (dd[0] - dd[1]);
			x = x0;
			y = y0;
			mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
			while (y < y1)
			{
				if (dp <= 0)
				{
					dp = dp + deltaE;
					y++;
				}
				else
				{
					dp = dp + deltaNE;
					x++;
					y++;
				}
			mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
			}
		}
	}
	else
	{
		if (dd[0] >= dd[1])
		{
			//cas3
			dp = 2 * dd[1] - dd[0];
			deltaE = 2 * dd[1];
			deltaNE = 2 * (dd[1] - dd[0]);
			x = x0;
			y = y0;
			mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
			while (x > x1)
			{
				if (dp <= 0)
				{
					dp = dp + deltaE;
					x--;
				}
				else
				{
					dp = dp + deltaNE;
					x--;
					y++;
				}
			mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
			}
		}
		else
		{
			//cas4
			dp = 2 * dd[0] - dd[1];
			deltaE = 2 * dd[0];
			deltaNE = 2 * (dd[0] - dd[1]);
			x = x0;
			y = y0;
			mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
			while (x > x1)
			{
				if (dp <= 0)
				{
					dp = dp + deltaE;
					y++;
				}
				else
				{
					dp = dp + deltaNE;
					x--;
					y++;
				}
			mlx_pixel_put(env->mlx, env->win, x, y, 0x00FFFFFF);
			}
		}
	}
}